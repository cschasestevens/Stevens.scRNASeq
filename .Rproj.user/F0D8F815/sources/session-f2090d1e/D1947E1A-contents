#---- testing ----

# Test package installation from Github
devtools::install_github("cschasestevens/Stevens.scRNASeq", ref = "master")
# Install auxiliary library for Seurat FindAllMarkers() function
devtools::install_github("immunogenomics/presto")
# load package
library(Stevens.scRNASeq)
## Change working directory to a separate folder, then test functions
setwd("/home/ncsteven/analyze/Stevens.scRNASeq.test")
## If running in WSL2, make sure to increase the memory limit by creating a .wslconfig file in the user directory.
## May have to install packages from Bioconductor if not already present on machine.

#---- Data processing ----
# Dataset input parameters
list.params <- Create.proc.params(
  "data/",
  # Dataset-specific columns
  data.frame(
    # ID column name (splits by underscore, should be listed first in folder name as in 'D24S_LAE_KO_D28')
    "Code" = unlist(lapply(strsplit(basename(list.files("data/")),"_",fixed = T),"[",1)),
    # 1st metadata column (include in CellRanger folder name)
    "NKX2.1" = as.factor(ifelse(grepl("NG",basename(list.files("data/"))),"NG","KO")),
    # 2nd metadata column
    "Airway" = as.factor(ifelse(grepl("LAE",basename(list.files("data/"))),"LAE","SAE")),
    # 3rd metadata column (add/remove columns as needed)
    "Time" = as.factor(ifelse(grepl("D28",basename(list.files("data/"))),"D28","D7"))
    )
  )

# Process single file
proc.data <- sc.process.file(
  # parameter list
  list.params,
  # sample ID
  1,
  # adj.rho proportion
  0.1,
  # minimum cells per feature
  5,
  # minimum features per cell
  200
  )

# Process batch
list.data <- sc.process.batch(
  # parameter list
  list.params,
  # adj.rho.proportion
  0.1,
  # min. cells/feature
  5,
  # min. feat/cell
  200,
  # Run in parallel?
  TRUE,
  # Proportion of cores to use (set to 1 if FALSE)
  0.5
  )

saveRDS(
  list.data,
  "processed/test.data.rds"
  )

list.data <- readRDS("processed/test.data.rds")
# Updated parameter list
list.params <- dplyr::bind_rows(
  setNames(
    lapply(
      seq.int(
        1,
        length(list.data),
        1
        ),
      function(x)
        list.data[[x]][[2]]
      ),
    names(list.data)
    )
  )
sc.plot.rho(list.params)
# Formatted integration list
list.integrate <- setNames(
  lapply(
    seq.int(
      1,
      length(list.data),
      1
      ),
    function(x)
      list.data[[x]][[1]]
    ),
  names(list.data)
  )
# Integrate data
d.integrated <- sc.integrate.data(
  list.integrate,
  TRUE,
  0.5
  )
d.integrated <- readRDS("processed/data.integrated.rds")
## Integration QC
ggplot2::ggsave(
  "analysis/plot.integration.qc.png",
  sc.integration.qc(d.integrated,"seurat_clusters"),
  width = 24,
  height = 8,
  dpi = 700)






#---- PCA, UMAP, and Gene Expression Visualization ----
# Load gene list
list.genes <- read.table(
  "ref/gene.list.txt",
  sep = "\t",
  header = T
  )
# Cell Type List (for Cell Type Prediction)
list.ct <- c(
  "Secretory",
  "SecretoryCiliated",
  "Ciliated",
  "Basal",
  "Suprabasal",
  "Cycling",
  "Ionocyte/NE"
  )
# Load integrated data
if(!exists("d.integrated")) {
  d.integrated <- readRDS("analysis/D28.integrated.analysis.annotated.rds")
  }
# Load reference data for annotating clusters
d.ref <- readRDS("ref/Ken_HBE10xLSAE5codes1mSAE_cls19noLQ15_seurat.rds")

# metadata columns for plot overlays
list.p.cols <- c(
  "Code","Airway",
  "Knockout"
  )

# Run PCA
d1 <- sc.pca(d.integrated)
d1.pca <- sc.pca.plot(
  d1,
  c("Code","Airway","Knockout","seurat_clusters")
  )
ggplot2::ggsave(
  "analysis/plot.pca.panel.png",
  d1.pca,
  width = 36,
  height = 12,
  dpi = 700)

# Determine optimal number of dimensions to use, then run UMAP
d1 <- Seurat::RunUMAP(
  object = d1,
  dims = 1:20,
  n.components = 3
  )
d1 <- SeuratObject::AddMetaData(
  d1,
  factor(
    d1@meta.data$seurat_clusters,
    levels = c(
      seq.int(
        0,
        length(
          unique(
            d1@meta.data$seurat_clusters
            )
          ) - 1,
          1
        )
      )
    ),
  col.name = "seurat.clusters"
  )
d1.umap1 <- sc.umap.panel(
  d1,
  c("seurat.clusters",list.p.cols)
  )
ggplot2::ggsave(
  "analysis/plot.umap.panel.png",
  d1.umap1,
  height = 16,
  width = 32,
  dpi = 400
  )


# Plot UMAPs of subsetted data
list.analysis.subs <- data.frame(
  "Comp.no" = c(1,2,3,4),
  "Airway" = c("SAE","SAE","LAE","LAE"),
  "Knockout" = c("Control","KO","Control","KO")
  )

list.analysis.subs.d <- setNames(
  lapply(
    list.analysis.subs[["Comp.no"]],
    function(x) {
      l.sub <- BiocGenerics::subset(
        d.integrated,
        subset = Airway == list.analysis.subs[x,"Airway"] &
          Knockout == list.analysis.subs[x,"Knockout"]
        )
      Seurat::DefaultAssay(l.sub) <- "RNA"
      return(l.sub)
    }
  ),
  c(
    paste(
      list.analysis.subs[["Airway"]],
      list.analysis.subs[["Knockout"]],
      sep = "."
    )
  )
)
# Create UMAPs of subsetted Seurat objects
list.analysis.subs.p <- ggpubr::ggarrange(
  plotlist = lapply(
    list.analysis.subs[["Comp.no"]],
    function(x) {

      d1.umap1 <- sc.umap.panel(
        list.analysis.subs.d[[x]],
        c("seurat.clusters",list.p.cols)
      )
      ggplot2::ggsave(
        paste(
          "analysis/plot.umap.panel.",
          list.analysis.subs[x,"Airway"],
          list.analysis.subs[x,"Knockout"],
          ".png",sep = ""),
        d1.umap1,
        height = 16,
        width = 32,
        dpi = 400
      )
    }
  ),
  nrow = 2,
  ncol = 2,
  common.legend = F)


# Create Gene expression UMAPs based on a specific gene list
sc.umap.panel.gene.list(
  # Gene list
  list.genes[[1]],
  # Seurat Object
  d.integrated,
  # Group variable
  "CellType",
  # Color scheme
  col.univ()[1:length(levels(d.integrated@meta.data[["CellType"]]))],
  # Color Names
  c(levels(d.integrated@meta.data[["CellType"]])),
  # legend x-position
  0.95,
  # legend y-position
  0.95,
  # Run in parallel? (set to FALSE if on Windows)
  TRUE,
  # Percentage of available cores to use
  0.5
  )

## Single plot
sc.umap.panel.gene(
  # Seurat Object
  d.integrated,
  # Group variable
  "CellType",
  # Gene name
  "CFTR",
  # Color scheme
  col.univ()[1:length(levels(d.integrated@meta.data[["CellType"]]))],
  # Color Names
  c(levels(d.integrated@meta.data[["CellType"]])),
  # legend x-position
  0.95,
  # legend y-position
  0.95
  )





#---- Cell Type Prediction ----

# Automatic cell type prediction
gc(reset = T)
d.list <- sc.predict.clusters(
  # Input Seurat object
  d.integrated,
  # Reference Seurat object
  d.ref,
  # Future size of created objects (in MB)
  5000,
  # Cluster column name
  "seurat.clusters",
  # Vector of group metadata columns
  list.p.cols,
  # Run in parallel? (Set to FALSE if running on Windows)
  TRUE,
  # Proportion of available cores to use
  0.25
  )

saveRDS(d.list,"analysis/data.with.predictions.rds")

# Manual assignment for modifying existing CellType and CellGroup columns
d.list.ct <- dplyr::select(
  dplyr::left_join(
    d.list$`Predicted Clusters`@meta.data["seurat.clusters"],
    data.frame(
      "seurat.clusters" = paste(sort(unique(d.list$`Predicted Clusters`@meta.data$seurat.clusters))),
      "CellType" = factor(
        c("0.Basal","1.Suprabasal","2.Secretory","3.SecretoryCiliated","4.Secretory",
          "5.SecretoryCiliated","6.Secretory","7.Ciliated","8.Ciliated","9.Ciliated",
          "10.Cycling","11.Secretory","12.SecretoryCiliated","13.Secretory","14.Cycling",
          "15.SecretoryCiliated","16.Secretory","17.SecretoryCiliated","18.Rare","19.Secretory",
          "20.Rare"),
        levels = c("0.Basal","1.Suprabasal","2.Secretory","3.SecretoryCiliated","4.Secretory",
                   "5.SecretoryCiliated","6.Secretory","7.Ciliated","8.Ciliated","9.Ciliated",
                   "10.Cycling","11.Secretory","12.SecretoryCiliated","13.Secretory","14.Cycling",
                   "15.SecretoryCiliated","16.Secretory","17.SecretoryCiliated","18.Rare","19.Secretory",
                   "20.Rare")),
      "CellGroup" = factor(
        c("Basal","Suprabasal","Secretory","SecretoryCiliated","Secretory",
          "SecretoryCiliated","Secretory","Ciliated","Ciliated","Ciliated",
          "Cycling","Secretory","SecretoryCiliated","Secretory","Cycling",
          "SecretoryCiliated","Secretory","SecretoryCiliated","Rare","Secretory",
          "Rare"),
        levels = c("Basal","Suprabasal","Cycling","Ciliated","SecretoryCiliated",
                   "Secretory","Rare"))
      ),
    by = "seurat.clusters"),
  .data[["CellType"]],.data[["CellGroup"]]
  )

d.list$`Predicted Clusters` <- SeuratObject::AddMetaData(
  d.list$`Predicted Clusters`,
  d.list.ct[["CellType"]],
  col.name = "CellType"
  )

d.list$`Predicted Clusters` <- SeuratObject::AddMetaData(
  d.list$`Predicted Clusters`,
  d.list.ct[["CellGroup"]],
  col.name = "CellGroup"
  )

## UMAP with final cluster assignments (Type and Group)
### Cell Type
ggplot2::ggsave(
  "analysis/plot.umap.CellType.png",
  sc.umap.standard(
    # Seurat object
    d.integrated,
    # metadata column
    "CellType"
    ),
  height = 8,
  width = 8,
  dpi = 700
  )
### Cell Group
ggplot2::ggsave(
  "analysis/plot.umap.CellGroup.png",
  sc.umap.standard(
    # Seurat object
    d.integrated,
    # metadata column
    "CellGroup"
    ),
  height = 8,
  width = 8,
  dpi = 700
  )

## Save analysis rds
saveRDS(d.list,"analysis/data.annotated.rds")




#---- Visualize Marker Genes ----

## Create Heatmap
p.heatmap.top10 <- sc.top10.marker.heatmap(
  # Seurat object
  d.integrated,
  # Cluster column
  "CellType",
  # Heatmap width
  36,
  # Heatmap height
  12,
  # Column fontsize
  4,
  # Row fontsize
  8
  )

## Save
png(
  "analysis/plot.heatmap.top10.markers.png",
  width = 40,
  height = 14,
  units = "cm",
  res = 1000
  )
print(p.heatmap.top10)
dev.off()





#---- Analyze a Reclustered Subset of a scRNA-Seq Experiment ----

# Recluster based on two cell types
d.recluster <- sc.recluster.data(
  # Seurat object
  d.integrated,
  # Cell types for subsetting
  c("Secretory","SecretoryCiliated"),
  # gene list file (as vector)
  "ref/gene.list.txt",
  # metadata column list
  list.p.cols,
  # marker gene heatmap width
  36,
  # marker gene heatmap height
  12,
  # marker gene heatmap column fontsize
  6,
  # marker gene heatmap row fontsize
  8,
  # run in parallel? (Set to FALSE if on Windows)
  TRUE,
  # core percentage to use for plotting gene expression umaps
  0.5
  )





#---- Statistical analysis ----
#### DGEA ####
# Load gene list
list.genes <- read.table(
  "ref/gene.list.txt",
  sep = "\t",
  header = T
  )
# Load data
if(!exists("d.analysis")) {
  d.analysis <- readRDS("analysis/D28.integrated.analysis.annotated.rds")
  }
# metadata columns for plot overlays
list.p.cols <- c(
  "Code","Airway",
  "Knockout"
  )

# Subset and Run DGEA
d1 <- BiocGenerics::subset(
  d.analysis,
  subset = Airway == "SAE"
  )
remove(d.analysis)

dgea.output <- sc.DGEA(
  # Seurat object
  d1,
  # metadata column list
  c(list.p.cols,"CellType","nFeature_RNA"),
  # Cell type column name
  "CellType",
  # MAST comparison name
  "KnockoutKO",
  # MAST name (user-provided)
  "KO vs. NG ",
  # Formula
  as.formula(
    paste(
      "~","Knockout","+",
      "nFeature_RNA",
      sep = " "
      )
    ),
  # run in parallel? (Set to FALSE if on Windows)
  TRUE,
  # core percentage to use
  0.5
  )





#### Visualize DGEA results ####
if(!exists("dgea.output") & file.exists("analysis/object.dgea.result.rds")) {
  dgea.output <- readRDS("analysis/object.dgea.result.rds")
  }
# Top-10 DEG heatmap
p.heatmap <- sc.top10.deg.heatmap(
  # DGEA results list
  dgea.output,
  # Seurat object
  d1,
  # Cluster column name
  "CellType",
  # Heatmap width
  36,
  # Heatmap height
  12,
  # Heatmap column font size
  6,
  # Heatmap row font size
  8,
  # Comparison name
  "KO vs. NG"
  )

png(
  "analysis/plot.heatmap.top10.deg.KOvNG.png",
  width = 44,
  height = 14,
  units = "cm",
  res = 1600
  )
print(p.heatmap)
dev.off()


# DEG Dot Plot
p.dotplot <- sc.top10.deg.dotplot(
  # Use a custom gene list ('cstm.list') or dgea.results object ('deg.list')
  "deg.list",
  # DGEA results list or custom gene list
  dgea.output,
  # Seurat object
  d1,
  # Pattern for matching to specific cell clusters (separate entries by |)
  "2.Se|3.Se|6.Se",
  # Clustering/CellType column name
  "CellType",
  # Group variable(s)
  c("Knockout","Airway")
  )

## Save
ggplot2::ggsave(
  "analysis/plot.dotplot.top10.deg.KOvNG.png",
  p.dotplot$Plot,
  width = 20,
  height = 8,
  dpi = 700
  )


# DEG Volcano Plot
## Single
p.vol <- sc.volcano(
  # DGEA results list or custom gene list
  dgea.output,
  # Cell type
  "2.Secretory",
  # Comparison name
  unique(dgea.output[[1]][["Comparison"]][[1]]),
  # P-value cutoff
  0.005,
  # Fold change cutoff
  0.25,
  # Fold change limit
  6
  )

ggplot2::ggsave(
  "analysis/plot.volplot.deg.KOvNG.2Sec.png",
  p.vol,
  width = 10,
  height = 8,
  dpi = 700
  )





#### Enrichment Analysis *Under Development* ####

# Performs GO enrichment analysis for chosen DGEA results list

## Input is a data frame that contains gene names, log fold-changes, and DGEA p-values
## Uses raw p-values as KS test adjusts terms for multiple corrections


# Source script
source(
  "Scripts/4.5.GO.stats.R",
  local = knitr::knit_global()
)

# Load DGEA list (if not present)
dgea <- read.table(
  "Analysis/Reclustered/dgea.results.secretory.txt",
  header = T,
  sep = "\t"
)

# Define gene, fold-change, p-value, and cell type columns (in order)
p.col <- c("GENE","logFC","H.pval","CellType")
name1 <- "Analysis/Reclustered/20240424.GO.LSAE.orig.recluster.output.rds"

# Create GO input
GO.input <- fun.GO.setup(
  # Input DGEA result df
  dgea,
  # GO Input path
  "Analysis/Reclustered/20240424.GO.LSAE.orig.recluster.input.rds"
)

# Run GO enrichment for all clusters (source script again)
source(
  "Scripts/4.5.GO.stats.R",
  local = knitr::knit_global()
)



# Source script
source(
  "Scripts/4.5b.GO.plots.R",
  local = knitr::knit_global()
)

# Create individual plots

ggsave(
  "Analysis/Reclustered/GO.LSAE.orig.recluster.plot.12SecMF.png",
  fun.GO.plot(
    # Input GO df
    GO.output$`Molecular Function`$`12`$GO.output,
    # Title
    "12.Secretory LAE vs. SAE TopGO: Molecular Function"
  ),
  width = 12,
  height = 12,
  dpi = 600
)




















# Determine networks for all enrichment results in Section 1
## df - Data frame of enrichment result from one of BP,MF, or CC results for chosen cell type
## ont1 - GO ontology to use for network creation (one of: GOBPPARENTS, GOCCPARENTS, or GOMFPARENTS)
## term.root - root GO term for determining node levels (one of: GO:0008150 {BP}, GO:0003674 {MF}, or GO:0005575 {CC})

# Source group-wise function for network generation

source("1_Scripts/sc_34AN_GO_hir.R",
       local = knitr::knit_global())

# Verify that all GO terms have numeric raw and FDR p-values



# Run for BP, MF, and CC
# Output indicates if a network was generated; re-run manually if automatic network fails

## BP

GO.BP.net.list <- lapply(GO.comb[[1]], function(x)
  GO.hierarchy.fun(x[[1]],
                   GOBPPARENTS,
                   "BP",
                   "GO:0008150")
)

## MF

GO.MF.net.list <- lapply(GO.comb[[2]], function(x)
  GO.hierarchy.fun(x[[1]],
                   GOMFPARENTS,
                   "MF",
                   "GO:0003674")
)

## CC

GO.CC.net.list <- lapply(GO.comb[[3]], function(x)
  GO.hierarchy.fun(x[[1]],
                   GOCCPARENTS,
                   "CC",
                   "GO:0005575")
)

# Return missing networks

GO.net.miss.fun <- function(l1) {

  which(l1 == "Unable to create network: use alternate function")

}

GO.BP.mis <- GO.net.miss.fun(GO.BP.net.list)
GO.MF.mis <- GO.net.miss.fun(GO.MF.net.list)
GO.CC.mis <- GO.net.miss.fun(GO.CC.net.list)

## Save each for quick plot creation

saveRDS(GO.BP.net.list,
        "3_Analysis/4_Plots/6_GO/GO_BP_net.rds")

saveRDS(GO.MF.net.list,
        "3_Analysis/4_Plots/6_GO/GO_MF_net.rds")

saveRDS(GO.CC.net.list,
        "3_Analysis/4_Plots/6_GO/GO_CC_net.rds")



## Read RDS if available

# readRDS("pathtofile.rds")

# Sunburst plot function

source("1_Scripts/sc_34AN_GO_plot_sun.R",
       local = knitr::knit_global())

# Dendrogram plot function

source("1_Scripts/sc_34AN_GO_plot_den.R",
       local = knitr::knit_global())

# Create for each network and save with and without legend

## BP

lapply(GO.BP.net.list,
       function(x) {

         GO.plot.sun(x[[1]],
                     x[[2]],
                     F,
                     "noleg",
                     "3_Analysis/4_Plots/6_GO/",
                     "BP")

         GO.plot.sun(x[[1]],
                     x[[2]],
                     T,
                     "leg",
                     "3_Analysis/4_Plots/6_GO/",
                     "BP")

       })


lapply(GO.BP.net.list,
       function(x) {

         GO.plot.den(x[[1]],
                     x[[2]],
                     "3_Analysis/4_Plots/6_GO/",
                     "BP")

       })


## MF

lapply(GO.MF.net.list,
       function(x) {

         GO.plot.sun(x[[1]],
                     x[[2]],
                     F,
                     "noleg",
                     "MF")

         GO.plot.sun(x[[1]],
                     x[[2]],
                     T,
                     "leg",
                     "MF")

       })


lapply(GO.MF.net.list,
       function(x) {

         GO.plot.den(x[[1]],
                     x[[2]],
                     "3_Analysis/4_Plots/6_GO/",
                     "MF")

       })


## CC

lapply(GO.CC.net.list,
       function(x) {

         GO.plot.sun(x[[1]],
                     x[[2]],
                     F,
                     "noleg",
                     "CC")

         GO.plot.sun(x[[1]],
                     x[[2]],
                     T,
                     "leg",
                     "CC")

       })


lapply(GO.CC.net.list,
       function(x) {

         GO.plot.den(x[[1]],
                     x[[2]],
                     "3_Analysis/4_Plots/6_GO/",
                     "CC")

       })












































#### Archived ####



## Save table for ChemRICH
cr.in <- MSI.ChemRICH.input(
  # p-value input df
  d.p2.result,
  # fold change input df
  d.fold,
  # feature metadata
  md.feat,
  # grouping column for calculating ChemRICH
  "label.saturation"
)

write.table(
  cr.in,
  "data.ChemRICH.input.txt",
  col.names = T,
  row.names = F,
  sep = "\t"
  )

# load datasets for positive and negative (must have matching column names)
chemrich.input <- rbind(
  read.table(
    "data.pos.ChemRICH.input.ho3vssfa.txt",
    sep = "\t",
    header = T
    ),
  read.table(
    "data.neg.ChemRICH.input.ho3vssfa.txt",
    sep = "\t",
    header = T
    )
  )

# Create plots for specified comparisons
### 4/35,5/21,6/30,7/8,5/9,4/31,6/34,7/16
chemrich.plot <- MSI.run.ChemRICH(
  chemrich.input,
  7,
  16,
  3,
  "Class"
  )
MSI.plot.ChemRICH(
  chemrich.plot,
  "Lipid Class",
  "plot.ChemRICH.alvepi.male.ho3vssfa"
  )

## Volcano plot
ggsave(
  "plot.stats.vol.awepi.male.HDMO3vsCtrl.png",
  MSI.plot.vol(
    data.frame(
      "Name" = chemrich.input[["Name"]],
      "FC" = chemrich.input[[31]],
      "P" = chemrich.input[[4]]
      ),
    "FC","P","Name",4,
    "Male Airway Epithelium - HDM + O3 vs. Control"
    ),
  width = 8,
  height = 6,
  dpi = 800
  )




