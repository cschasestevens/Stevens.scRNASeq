# Find anchors for each subset and integrate each, then delete the pre-integration subset of Seurat objects

d.anchor.int.fun <- function(subset1,
                             # rds.path,
                             future.size) {
  
  ## Anchor function
  
  f.anchor.fun <- function(s1) {
    
    ## switch to multisession
    
    plan("multisession",
         workers = ifelse(length(subset1) < core.num.find.anchors,
                          length(subset1),
                          core.num.find.anchors))
    
    plan()
    
    options(future.globals.maxSize = future.size * 1024^2)
    
    ## Find integration anchors
    
    data.files.anchor <- FindIntegrationAnchors(object.list = s1,
                                                anchor.features = 4000, 
                                                dims = 1:50)
    
    ## switch back to sequential
    
    plan("sequential")
    
    plan()
    
    options(future.globals.maxSize = 500 * 1024^2)
    
    return(data.files.anchor)
    
  }
  
  ## run for chosen subset
  
  data.files.anchor1 <- f.anchor.fun(subset1)
  
  ## Integration function
  
  d.int.fun <- function(x) {
    
    data.files.merged <- IntegrateData(anchorset = x,
                                       dims = 1:50)
    
    return(data.files.merged)
    
  }
  
  
  data.files.merged1 <- d.int.fun(data.files.anchor1)
  
  ## Comment out the saveRDS function to save time
  
  # saveRDS(data.files.merged1,
  #         rds.path)
  
  return(data.files.merged1)
  
}











fun.integration.2 <- function(
    subset1,
    rds.path,
    core.num,
    future.size
) {
  
  ## Anchor function
  
  f.anchor.fun <- function(
    s1
  ) {
    
    ## switch to multisession
    
    plan(
      "multisession",
      workers = core.num
    )
    
    plan()
    
    options(
      future.globals.maxSize = future.size * 
        1024^2
    )
    
    ## Find integration anchors
    
    data.files.anchor <- FindIntegrationAnchors(
      object.list = s1,
      anchor.features = 4000, 
      dims = 1:50
    )
    
    ## switch back to sequential
    
    plan(
      "sequential")
    
    plan()
    
    options(
      future.globals.maxSize = 500 * 1024^2
    )
    
    return(data.files.anchor)
    
  }
  
  
  ## run for chosen subset
  
  data.files.anchor1 <- f.anchor.fun(
    subset1)
  
  
  ## Integration function
  
  d.int.fun <- function(x) {
    
    data.files.merged <- IntegrateData(
      anchorset = x,
      dims = 1:50
    )
    
    return(data.files.merged)
    
  }
  
  data.files.merged1 <- d.int.fun(
    data.files.anchor1
  )
  
  saveRDS(
    data.files.merged1,
    rds.path
  )
  
  return(data.files.merged1)
  
}














# Remove pre-normalized Seurat objects

remove(data.list.ser)

# Find integration anchors (in parallel)

## Split into multiple sets and integrate separately to conserve computational resources

data.list.norm <- readRDS("3_Analysis/1_QC/1_posnorm_data.rds")

data.files.integrated <- lapply(data.list.norm,
                                function(x) x[[1]])

remove(data.list.norm)

## Subset

data.files.integrated.list <- vector("list",
                                     length = num.batch)

for (i in 1:length(data.files.integrated.list)) {
  
  data.files.integrated.list[[i]] <- data.files.integrated[q.subs[[i]]]
  
}


## remove compiled list

remove(data.files.integrated)


## Run integration function for each sample subset

source("1_Scripts/sc_17QC_integrate.R",
       local = knitr::knit_global())

### First Iteration

data.files.merged.list1 <- lapply(data.files.integrated.list,
                                  function(x) d.anchor.int.fun(x,
                                                               5000))

remove(data.files.integrated.list)


### Verify that all samples are present in integrated subsets

unique(levels(c(data.files.merged.list1[[1]]@active.ident,
                data.files.merged.list1[[2]]@active.ident,
                data.files.merged.list1[[3]]@active.ident,
                data.files.merged.list1[[4]]@active.ident)))



# repeat anchor/integration function for subsets 1-2 then 3-4

data.files.merged.list2 <- list(list(data.files.merged.list1[[1]],
                                     data.files.merged.list1[[2]]),
                                list(data.files.merged.list1[[3]],
                                     data.files.merged.list1[[4]]))

data.files.merged.list2 <- lapply(data.files.merged.list2,
                                  function(x) d.anchor.int.fun(x,
                                                               7500))

remove(data.files.merged.list1)


### Verify that all samples are present in integrated subsets

unique(levels(c(data.files.merged.list2[[1]]@active.ident,
                data.files.merged.list2[[2]]@active.ident)))



# Last iteration: find integration anchors/integrate pairs 1 & 2

data.files.merged.all <- d.anchor.int.fun(data.files.merged.list2,
                                          13000)