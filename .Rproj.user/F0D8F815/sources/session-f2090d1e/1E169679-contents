---
title: "scRNA-Seq Main"
output: 
  html_document: 
    toc: yes
    toc_float: TRUE
    toc_depth: 2
    theme: cerulean
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = F, 
                      warning = F,
                      message = F,
                      dpi = 600,
                      fig.width = 7,
                      cache = T,
                      dev = "png")


```


# **Load Libraries and Plot Themes**

```{r, echo=F, fig.align= "center", results=T, message=T, warning=T, eval=T}

# Loads all libraries, color schemes, and plot themes

source("Scripts/4.1.processing.libs.themes.R",
       local = knitr::knit_global())


```







# **Dataset-specific Inputs**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}
# Parameter list

## Global parameters

list.p <- data.frame(
  # Path to integrated Seurat object
  d.path = "Processed/",
  # Number of metadata columns in input data
  md = 35,
  a.path = "Analysis/"
  )

## Study groups

list.p.cols <- c(
  "Code","Airway","Batch",
  "Knockout","Time"
)

## Gene and Cell Type lists

### Hong list

list.g.1 <- c(
  "CFTR","FOXI1","SCGB1A1",
  "SCGB3A2","MUC5AC","MUC5B",
  "FOXJ1","KRT5","SFTPB",
  "IFI27","IL1R1","IL1A",
  "IL1B","IL16","NKX2-1"
  )

### Ken list 1: rare cell genes

list.g.2 <- c(
  "CFTR","FOXI1","BSND",
  "ASCL3","CLCNKB","ATP6V1C2",
  "POU2F3","ALOX5","IL25",
  "GRP","ASCL1","CALCA"
  )

### Ken list 2

list.g.3 <- c(
  "CFTR","FOXI1","SCGB1A1",
  "SCGB3A2","MUC5AC","MUC5B",
  "FOXJ1","KRT5","NKX2-1",
  "SFTPB","IFI27","IL1R1",
  "IL1A","IL1B","IL16",
  "ICAM1","CEACAM6","SERPINB3"
  )

# define gene list

ken.list <- c(
  # Secretory Cell Markers (Orig.recluster # 12)
  "SFTPB","HLA-DPB1","LTF",
  "KLK13","HP","SCGB3A2",
  "HLA-DQA1","HLA-DPA1","RNASE1",
  "HLA-DQA2","TMEM45A","ATOH8",
  # Goblet Cell Markers
  "ITLN1","FOXA3","MUC5AC",
  "MUC5B","SPDEF","XBP1",
  "CEACAM5","AGR2","FCGBP",
  "TFF2"
  )


### Levels for Grouping Cell Type Clusters

list.ct <- c(
  "Secretory",
  "SecretoryCiliated",
  "Ciliated",
  "Basal",
  "Suprabasal",
  "Cycling",
  "Ionocyte/NE"
  )





# Load dataset (if not analyzing sequentially)

## Integrated (All)

list.analysis <- readRDS(
  paste(
    list.p$a.path,
    "RDS/lsae.analysis.rds",
    sep = ""
  )
)

## Secretory subset
list.analysis <- list.analysis.subset
list.analysis <- readRDS(
  "Analysis/RDS/D28.integrated.analysis.annotated.secretory.subs.rds"
  )


# Load list data along with Seurat

list.analysis <- c(
  list.analysis,
  readRDS(
    paste(
      list.p$a.path,
      "RDS/lsae.analysis.list.rds",
      sep = ""
      )
    )
  )

names(list.analysis) <- c(
  "Seurat",
  names(
    list.analysis[2:length(
      list.analysis
      )]
    )
  )





# Define subsets for performing DGEA on Seurat object

l.subsets <- data.frame(
  "Airway" = c(
    "LAE|SAE","LAE|SAE","LAE|SAE","LAE|SAE",
    "LAE","LAE","SAE","SAE"
  ),
  "Knockout" = c(
    "KO","Control","KO","Control",
    "KO|Control","KO|Control","KO|Control","KO|Control"
  )
  # "Time" = c(
  #   "D7","D7","D28","D28",
  #   "D7","D28","D7","D28",
  #   "D7|D28","D7|D28","D7|D28","D7|D28"
  # )
)

# One variable only
l.subsets <- data.frame(
  "Airway" = c(
    "LAE","SAE"
  ),
  "Knockout" = c(
    "KO|Control","KO|Control"
  )
  # "Time" = c(
  #   "D7","D7","D28","D28",
  #   "D7","D28","D7","D28",
  #   "D7|D28","D7|D28","D7|D28","D7|D28"
  # )
)


l.subsets <- data.frame(
    "Comp.no" = seq(
      1:nrow(
        l.subsets
        )
      ),
    l.subsets,
    "Name" = paste(
      gsub(
        "\\|","vs",
        l.subsets[,1]
      ),
      gsub(
        "\\|","vs",
        l.subsets[,2]
      ),
      # gsub(
      #   "\\|","vs",
      #   l.subsets[,3]
      # ),
      sep = "."
      )
    )


## Add MAST contrast and comparison names
l.subsets <- data.frame(
  l.subsets,
  "MAST.cont" = paste(
    as.vector(
  lapply(
    l.subsets[["Comp.no"]],
    function(x)
    {
      
      names(
        l.subsets[grepl(
          l.subsets[x,
                    grepl(
                      "\\|",
                      l.subsets[x,]
                      )],
          l.subsets
          )]
        )[1]
      
    }
  )
),
ifelse(
  as.vector(
  lapply(
    l.subsets[["Comp.no"]],
    function(x)
    {
      
      names(
        l.subsets[grepl(
          l.subsets[x,
                    grepl(
                      "\\|",
                      l.subsets[x,]
                      )],
          l.subsets
          )]
        )[1]
      
    }
  )
) == "Airway",
"SAE",
ifelse(
  as.vector(
  lapply(
    l.subsets[["Comp.no"]],
    function(x)
    {
      
      names(
        l.subsets[grepl(
          l.subsets[x,
                    grepl(
                      "\\|",
                      l.subsets[x,]
                      )],
          l.subsets
          )]
        )[1]
      }
    )
  ) == "Knockout",
  "KO",
  "D28")
),
sep = ""
  ),
  "MAST.name" = l.subsets[["Name"]]
)



remove(list.analysis,list.analysis.subset)
gc(reset = T)

```














# **3.2. Differential Gene Expression Analysis**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}

# Conduct DGEA
# IMPORTANT: Script can take up to several hours to finish.


## Source function
source(
  "Scripts/4.2.DGEA.R",
  local = knitr::knit_global()
  )


## Create input SCE (single)

# list.analysis[["DGEA.input"]] <- fun.dge.input(
#   list.analysis$Seurat,
#   c(
#     "Airway","Knockout",
#     "Time","CellType",
#     "nFeature_RNA"
#     )
# )

## Create input SCE (subsets)

list.analysis.dgea <- setNames(
  lapply(
    l.subsets[["Comp.no"]],
    function(x) {
      
      fun.dge.subset.input(
        list.analysis,
        c(
          "Airway","Knockout",
          "CellGroup","nFeature_RNA"
          ),
        l.subsets[x,2],
        l.subsets[x,3],
        "Airway",
        "Knockout",
        "CellGroup"
        )
      }
    ),
  c(
    l.subsets[["Name"]]
    )
  )

## Single DGEA input
list.analysis.dgea <- fun.dge.single.input(
  list.analysis,
  c(
    "Airway","recluster",
    "nFeature_RNA"
    ),
  "recluster"
  )



## Remove all Seurat objects prior to DGEA

remove(list.analysis)

# Run DGEA (single)

list.analysis.dgea.result <- lapply(
  list.analysis.dgea[["CellType"]],
  function(x) 
    fun.dge.run(
      # CellType
      x,
      # SCE input object
      list.analysis.dgea[["SCE"]],
      # GLM formula
      as.formula(
        paste(
          "~","Airway","+",
          "nFeature_RNA",
          sep = " "
          )
        ),
      "recluster",
      # List of MAST comparisons (uses leading factor for names)
      c(
        # "KnockoutKO",
        "AirwaySAE"
        # "TimeD28"
      ),
      # List of comparison names for output
      c(
        # "KO vs. NG",
        "SAE vs. LAE"
        # "D28 vs. D7"
      )
      )
  )


# Run DGEA (subsets)

list.analysis.dgea.result <- lapply(
  l.subsets[["Comp.no"]],
  function(x) 
    lapply(
      list.analysis.dgea[[x]][["CellGroup"]],
      function(y) 
        fun.dge.run(
          # CellType
          y,
          # SCE input object
          list.analysis.dgea[[x]][["SCE"]],
          # GLM formula
          as.formula(
            paste(
              "~","Knockout","+",
              # "Airway","+",
              # "Time","+",
              "nFeature_RNA",
              sep = " "
              )
            ),
          # Grouping column
          "CellGroup",
          # List of MAST comparisons (uses leading factor for names)
          c(
            l.subsets[x,"MAST.cont"]
          ),
          # List of comparison names for output
          c(
            l.subsets[x,"MAST.name"]
            )
          )
      )
  )







list.analysis.dgea.result <- readRDS("D28.integrated.DGEA.result.background.rds")

# Format output and export

## DGEA and missing fold change lists

list.dgea.output <- fun.dge.output(
  # DGEA input list
  list.analysis.dgea,
  # Select list level ("[" for level 1,"[[" for 2)
  "[[",
  # DGEA output list
  list.analysis.dgea.result2
  )

### for single comparison output

list.dgea.output <- fun.dge.output.single(
  # DGEA result list
  list.analysis.dgea.result,
  # DGEA input list
  list.analysis.dgea,
  # Cell type column (for naming list elements)
  "CellGroup",
  # Select list level ("[" for level 1,"[[" for 2)
  "[["
  )


## Format output list if duplicates are present

list.dgea.output[[1]] <- list.dgea.output[[1]][!duplicated(
  list.dgea.output[[1]]
  ),]


## Export

write.table(
  list.dgea.output[[1]],
  file = "D28.integrated.dgea.results.celltype.txt",
  sep = "\t",
  col.names = T,
  row.names = F
)

write.table(
  list.dgea.output$DGEA.missing.FC,
  file = "Analysis/Integrated/dgea.missFC.table.txt",
  sep = "\t",
  col.names = T,
  row.names = F
)


## Remove list of SCE after successful DGEA result and re-load Seurat to list.analysis

remove(list.analysis.dgea,list.analysis.dgea1)

list.analysis <- readRDS("Analysis/RDS/D28.integrated.analysis.secretory.subs.rds")


## Save DGEA results as RDS

saveRDS(list.analysis.dgea.result2,
        "Analysis/RDS/lsae.analysis.dgea.result.unformatted.rds")

saveRDS(list.dgea.output[[1]],
        "D28.integrated.secretory.subs.DGEA.result.formatted.rds")



```





# **Visualize DGEA Results**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}

#---- Top 10 DEG heatmap per comparison and celltype (Need to add cluster numbers to heatmap) ----
## Load DGEA results if not already present
list.dgea.result <- readRDS("Analysis/Integrated/D28.integrated.secretory.subs.DGEA.result.formatted.rds")


## Source function

source(
  "Scripts/4.3.heatmaps.dgea.R",
  local = knitr::knit_global()
  )

## Change default assay of Seurat to RNA

DefaultAssay(list.analysis) <- "RNA"


## Run function and plot for selected comparisons

hm.dgea <- fun.hm.de.gene1(
  # DGEA results dataframe
  list.dgea.output,
  # Corresponding Seurat object
  list.analysis,
  # Data frame containing comparison list (from DGEA)
  l.subsets,
  # MAST contrast name
  "KnockoutKO",
  # MAST comparison string for filtering input data
  "KOvsControl.",
  # MAST fold change direction and name
  "KO vs. Control",
  # Number of top DEGs to include for each cell type/comparison
  10,
  # Should mitochondrial/ribosomal genes be removed?
  TRUE,
  # Grouping column
  "CellGroup",
  # List of celltypes to include in final heatmap
  c(
    "Basal",
    "Secretory",
    "SecretoryCiliated"
    ),
  # Heatmap column annotation name fontsize
  6,
  # Heatmap width (in cm)
  36,
  # Heatmap height (in cm)
  12,
  # Fontsize of column (gene) names
  4,
  # Heatmap title
  "Top 10 DEGs KO vs. Control"
  )



# For single comparisons

hm.dgea <- fun.hm.de.gene3(
  # DGEA results dataframe
  dgea.comb5,
  # Corresponding Seurat object
  list.analysis.subset,
  # Seurat clustering column name
  "Group2",
  # Number of top DEGs to include for each cell type/comparison
  10,
  # Should mitochondrial/ribosomal genes be removed?
  TRUE,
  # Heatmap column annotation name fontsize
  6,
  # Heatmap width (in cm)
  36,
  # Heatmap height (in cm)
  12,
  # Fontsize of column (gene) names
  6,
  # Heatmap title
  "Top 10 DEGs per grouped cluster (vs. 12.Secretory)"
  )
















png("Analysis/D28.original.heatmap.deg.secretory.grouped.png",
    width = 44,
    height = 14,
    units = "cm",
    res = 1600
)

print(hm.dgea$plot)

dev.off()





#---- Dot Plots ----

# Top-10 DEGs by CellType

## load Seurat (if not already present)
# list.analysis <- readRDS("Analysis/ lsae.analysis.D28.rds")

## To distinguish between similar cell type names, use cluster numbers separated by '|' instead
unique(list.analysis$CellType)


## Run dot plot function
d.dot.dge <- fun.dp.deg.top10(
  # Seurat object
  list.analysis,
  # DGEA results dataframe
  list.dgea.result,
  # cell type
  "2.Se|3.Se|6.Se",
  # comparison list (separate comparison groups by '|' with no spaces)
  "LAE.KOvsControl|SAE.KOvsControl",
  # grouping variables for plot
  c(
    "Airway",
    "Knockout"
    )
  )

## Save
ggsave(
  "Analysis/dot.integrated.secretory.subs.knockout.png",
  d.dot.dge$Plot,
  width = 20,
  height = 8,
  dpi = 700
  )


## Save with individual gene list
levels(list.analysis@meta.data$recluster)
list.analysis.lae <- subset(list.analysis,subset = Airway == "LAE")
list.analysis.sae <- subset(list.analysis,subset = Airway == "SAE")
ggsave(
  "Analysis/dot.integrated.secretory.subs.lae.knockout.png",
  fun.dp.deg.list(
    # Seurat object
    list.analysis.lae,
    # gene list
    ken.list[-22],
    # cell type column name
    "recluster",
    # cell type
    "0|1|2|3|5|6|7|8|9",
    # grouping variables for plot
    c(
      "Airway",
      "Knockout"
    )
  )[[2]],
  width = 16,
  height = 10,
  dpi = 700
  )





#---- Volcano Plots ----

## Subset data by comparison and cell type
list.dgea.result.split <- setNames(
  lapply(
    unique(
      list.dgea.result[["Comparison"]]),
    function(x) {
      setNames(
        lapply(
          unique(
            list.dgea.result[["CellType"]]
            ),
          function(y) {
          d <- list.dgea.result[list.dgea.result[["CellType"]] == y &
                list.dgea.result[["Comparison"]] == x,
                ]
          
          d[["log2FC"]] <- log2(exp(d[["logFC"]]))
          
          return(d)
          
            }
          ),
        c(
          unique(
            list.dgea.result[["CellType"]]
            )
          )
        )
      }
    ),
  c(
    unique(
      list.dgea.result[["Comparison"]]
      )
    )
  )

## Source single volcano plot function
source("Scripts/4.4.volplot.R",
       local = knitr::knit_global())

## Create plots for each Cell Type and Comparison
names(list.dgea.result.split[[1]])

lapply(
  names(list.dgea.result.split),
  function(x) {
    lapply(
      names(
        list.dgea.result.split[[1]]
        ),
      function(y) {
            tryCatch({
        ggsave(
          # filename
          paste(
            "Analysis/",
            unique(
              list.dgea.result.split[[x]][[y]][["Comparison"]]
              ),".",
            gsub("/",".",unique(
              list.dgea.result.split[[x]][[y]][["CellType"]]
              )),".",
            "DGEA.secretory.subs.png",sep = ""
            ),
          # plot
          fun.vol.s(
          # Input data frame
          list.dgea.result.split[[x]][[y]],
          # Fold change column name
          "log2FC",
          # P-value column name
          "H.qval",
          # label name
          "GENE",
          # Fold change limit (x-axis)
          4,
          # plot title
          paste(
            unique(
              list.dgea.result.split[[x]][[y]][["Comparison"]]
              ),
            gsub("/",".",unique(
              list.dgea.result.split[[x]][[y]][["CellType"]]
              )),
            "DGEA",sep = " "
            )
          ),
          width = 10,
          height = 10,
          dpi = 1000
          )
            },
  error = function(e){
    print(
      "Fold changes not present for selected comparison and cell type combination..."
      )
    })
        }
      )
    }
  )










  
## Plot individual: LSAE data set

vol.in <- list.dgea.celltype %>%
  dplyr::select(gene,
                logFC,
                H.qval,
                Cluster)

## Log2 Transform fold changes
  
vol.in[["Log2FC"]] <- log2(exp(vol.in$logFC))

## filter NA values

vol.in <- vol.in[!is.na(vol.in$Log2FC),]

names(vol.in) <- c("GENE","logFC","H.qval","CellType","log2FC")

## Plot each cell type

vol.in.type <- unique(vol.in$CellType)

list.vol <- vector("list",length = length(vol.in.type))

for (i in 1:length(list.vol)) {
  
  vol.in2 <- filter(vol.in,
                    CellType == vol.in.type[[i]])
  
  list.vol[[i]] <- p.fun.vol(vol.in2,
                             "log2FC",
                             "H.qval",
                             vol.in.type[[i]])
  
}


vol.out <- ggarrange(plotlist = list.vol[1:7],
                     nrow = 2,
                     ncol = 4,
                     common.legend = T,
                     legend = "bottom")

ggsave(paste(dir1,
             "SAEvsLAE_combined.png"),
       vol.out,
       width = 20,
       height = 10,
       dpi = 600)


lapply(
  seq.int(
    1,
    length(
      levels(
        list.dgea.result$CellType
        )
      ),
    1
    ),
  function(x) {
    tryCatch({
    ggsave(
  paste(
    "20240605.D28.integrated.volcano.plots/D28.integrated.vol.",
    levels(list.dgea.result$CellType)[[x]],
    ".SAE.KOvsControl.png",
    sep = ""
    ),
    fun.vol.s(
      #Input data
      list.dgea.result[
        list.dgea.result[["Comparison"]] == "SAE.KOvsControl" &
                         list.dgea.result[["CellType"]] == as.character(
                           levels(
                             list.dgea.result[["CellType"]])[[x]]
                           )
                       ,
                       ],
      #Fold change column
      "logFC",
      #P-value column
      "H.qval",
      #Plot label column
      "GENE",
      #Fold change limit
      5,
      #Plot title
      paste(
        "D28 Integrated",
        levels(list.dgea.result$CellType)[[x]],
        "SAE.KOvsControl",
        sep = " "
        )
      ),
    width = 12,
    height = 10,
    dpi = 600
    )
    },
  error = function(e){
    print(
      "Fold changes not present for selected comparison and cell type combination..."
      )
    }
    )
  }
)






```


# **Trajectory Analysis**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}

## Change default assay for integrated data

DefaultAssay(
  list.analysis$Seurat
  ) <- "RNA"

## Extract data matrix and metadata

### Counts

mat.tj <- GetAssayData(
  list.analysis$Seurat[["RNA"]],
  slot = "counts"
  )

### Metadata

mat.md <- list.analysis$Seurat@meta.data[,c(
  "CellType",
  "CellGroup",
  list.p.cols
  )]

mat.md[["Cluster"]] <- factor(
    as.numeric(
      gsub(
        "\\..*",
        "",
        as.character(
          mat.md[["CellType"]]
          )
        )
      ),
    levels = c(
      seq(
        1:max(
          as.numeric(
            gsub(
              "\\..*",
              "",
              as.character(
                mat.md[["CellType"]]
                )
              )
            )
          )
        )
      )
    )



mat.gn <- magrittr::set_rownames(
  setNames(
    as.data.frame(
      rownames(
        mat.tj
        )
      ),
    c(
      "gene_short_name"
      )
    ),
  c(
    rownames(
      mat.tj
      )
    )
  )


## Create trajectory data object

d.traj <- new_cell_data_set(
  mat.tj,
  cell_metadata = mat.md,
  gene_metadata = mat.gn
)

### Pre-process and remove sample differences

d.traj <- preprocess_cds(
  d.traj,
  num_dim = 30
)

plot_pc_variance_explained(
  d.traj
  )

d.traj <- align_cds(
  d.traj,
  num_dim = 30,
  alignment_group = "Code"
  )

d.traj <- reduce_dimension(
  d.traj,
  max_component = 3,
  cores = detectCores()*0.75
  )


## Trajectories

### Cluster cells

d.traj <- cluster_cells(
  d.traj
  )

### Plot partitions

plot_cells_3d(
  d.traj,
  color_cells_by = "partition"
  )

### Learn trajectories

d.traj <- learn_graph(
  d.traj
  )

plot_cells(d.traj,
           color_cells_by = "CellType",
           label_groups_by_cluster=T,
           label_leaves=T,
           label_branch_points=T)

### Pick root nodes and order cells

get_earliest_principal_node <- function(
    cds, 
    time_bin = "D7"
    ){
  
  cell_ids <- which(
    colData(
      cds
      )[, "Time"] == time_bin
    )
  
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  
  closest_vertex <- as.matrix(
    closest_vertex[colnames(
      cds
      ), 
      ]
    )
  
  root_pr_nodes <- igraph::V(
    principal_graph(
      cds
      )[["UMAP"]]
    )$name[as.numeric(
      names(
        which.max(
          table(
            closest_vertex[cell_ids,]
            )
          )
        )
      )]
  
  return(
    root_pr_nodes
    )
  
  }

d.traj <- order_cells(
  d.traj,
  root_pr_nodes = get_earliest_principal_node(
    d.traj
    )
  )









## Extract UMAP embeddings and plot

### Save plot (either 3D or 2D)

ggsave(
  paste(
    list.p$a.path,
    "umap.trajectory.code.2D.png",
    sep = ""
  ),
  fun.sc.umap.plot.traj.2D(
    # Monocle CDS object
    d.traj,
    # Variable for labeling clusters
    "CellType",
    # Variable for fill color
    "Code",
    # Color scheme
    ## Default colors
    # c(
    #   "#F8766D",
    #   "#008FC4"
    # )
    ## Custom
    col3a
  ),
  height = 8,
  width = 10,
  dpi = 700
)


ggsave(
  paste(
    list.p$a.path,
    "umap.trajectory.code.3D.png",
    sep = ""
  ),
  fun.sc.umap.plot.traj(
    # Monocle CDS object
    d.traj,
    # Variable for labeling clusters
    "CellType",
    # Variable for fill color
    "Code",
    # 3D UMAP params
    35,
    "text_repel",
    # Color scheme
    ## Default colors
    # c(
    #   "#F8766D",
    #   "#008FC4"
    # )
    ## Custom
    col3a
  ),
  height = 8,
  width = 10,
  dpi = 700
)





# Import matrix and create cell_data_set 
cds<-new_cell_data_set(mat, cell_metadata=meta, gene_metadata=sc.gene)
# Remove sample differences using alignment_group
cds<-preprocess_cds(cds, num_dim=30)
plot_pc_variance_explained(cds)
cds<-align_cds(cds, num_dim=30, alignment_group="Code")
cds<-reduce_dimension(cds, max_component=3, cores=32)
plot_cells(cds)
plot_cells(cds, color_cells_by="Code", label_cell_groups=FALSE)
plot_cells(cds, color_cells_by="Treatment", label_cell_groups=FALSE)
plot_cells(cds, color_cells_by="Group", label_cell_groups=FALSE)
plot_cells(cds, color_cells_by="predicted.id", label_cell_groups=T, group_label_size=6, graph_label_size=6)
plot_cells(cds, color_cells_by="CellType", label_cell_groups=T, group_label_size=6, graph_label_size=6)
# Cluster cells
cds<-cluster_cells(cds, resolution=1e-5)
plot_cells(cds, label_cell_groups=T, group_label_size=6, graph_label_size=6)
plot_cells(cds, color_cells_by="partition", group_cells_by="partition", label_cell_groups=T, group_label_size=6, graph_label_size=6)
# Get cell markers
marker_test_res<-top_markers(cds, genes_to_test_per_group=200, cores=32, verbose=F)
write.table(marker_test_res, file="Ken_sars2HBE10x_mnc3_cls6_geneMarkers.txt", sep="\t", col.names=T, row.names=F, quote=F)
top_specific_markers<-marker_test_res %>%
      filter(fraction_expressing >= 0.10) %>%
      group_by(cell_group) %>%
      top_n(10, pseudo_R2)
top_specific_marker_ids<-unique(top_specific_markers %>% pull(gene_id))
plot_genes_by_group(cds, top_specific_marker_ids, ordering_type="maximal_on_diag", max.size=3)
# Assign cell labels
colData(cds)$assignCellType<-as.character(clusters(cds))
colData(cds)$assignCellType<-dplyr::recode(colData(cds)$assignCellType,
                                                "1"="1.Basal",
                                                "2"="2.Ciliated",
                                                "3"="3.Suprabasal",
                                                "4"="4.Secretory",
                                                "5"="5.Infected.Day3",
                                                "6"="6.FOXN4+")

plot_cells(cds, color_cells_by="assignCellType", label_cell_groups=T, group_label_size=6, graph_label_size=6)

# Trajectory
cds<-learn_graph(cds, use_partition=F, verbose=F)
plot_cells(cds, label_groups_by_cluster=T, label_leaves=T, label_branch_points=T, group_label_size=6, graph_label_size=6)
plot_cells(cds, color_cells_by="Group", label_cell_groups=T, label_leaves=TRUE, label_branch_points=TRUE, graph_label_size=6)
plot_cells(cds, color_cells_by="predicted.id", label_cell_groups=T, label_leaves=TRUE, label_branch_points=TRUE, graph_label_size=6, group_label_size=6)
plot_cells(cds, color_cells_by="CellType", label_cell_groups=T, label_leaves=TRUE, label_branch_points=TRUE, graph_label_size=6, group_label_size=6)
plot_cells(cds, color_cells_by="assignCellType", label_cell_groups=T, label_leaves=TRUE, label_branch_points=TRUE, graph_label_size=6, group_label_size=6)
# Pick a start and calculate pseudotime
cds<-order_cells(cds)
plot_cells(cds, color_cells_by="pseudotime", label_cell_groups=FALSE, label_leaves=FALSE, label_branch_points=FALSE, graph_label_size=4)

# Save the data set
#saveRDS(cds, file="Ken_sars2HBE10x_mnc3cls6labeled_traj.rds")















```
















# **3.4. GO Enrichment Analysis**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}

# Performs GO enrichment analysis for chosen DGEA results list

## Input is a data frame that contains gene names, log fold-changes, and DGEA p-values
## Uses raw p-values as KS test adjusts terms for multiple corrections

#### Section 1: Perform GO Enrichment ####

# Source script
source(
  "Scripts/4.5.GO.stats.R",
  local = knitr::knit_global()
  )

# Load DGEA list (if not present)
dgea <- read.table(
  "Analysis/Reclustered/dgea.results.secretory.txt",
  header = T,
  sep = "\t"
  )

# Define gene, fold-change, p-value, and cell type columns (in order)
p.col <- c("GENE","logFC","H.pval","CellType")
name1 <- "Analysis/Reclustered/20240424.GO.LSAE.orig.recluster.output.rds"

# Create GO input
GO.input <- fun.GO.setup(
  # Input DGEA result df
  dgea,
  # GO Input path
  "Analysis/Reclustered/20240424.GO.LSAE.orig.recluster.input.rds"
  )

# Run GO enrichment for all clusters (source script again)
source(
  "Scripts/4.5.GO.stats.R",
  local = knitr::knit_global()
  )


#### Section 2: Quick Plotting of Top GO Terms ####

# Source script
source(
  "Scripts/4.5b.GO.plots.R",
  local = knitr::knit_global()
  )

# Create individual plots

ggsave(
  "Analysis/Reclustered/GO.LSAE.orig.recluster.plot.12SecMF.png",
  fun.GO.plot(
  # Input GO df
  GO.output$`Molecular Function`$`12`$GO.output,
  # Title
  "12.Secretory LAE vs. SAE TopGO: Molecular Function"
  ),
  width = 12,
  height = 12,
  dpi = 600
  )



















#### Section 3: Create Hierarchies for Plotting ####

# Determine networks for all enrichment results in Section 1
## df - Data frame of enrichment result from one of BP,MF, or CC results for chosen cell type
## ont1 - GO ontology to use for network creation (one of: GOBPPARENTS, GOCCPARENTS, or GOMFPARENTS)
## term.root - root GO term for determining node levels (one of: GO:0008150 {BP}, GO:0003674 {MF}, or GO:0005575 {CC})

# Source group-wise function for network generation

source("1_Scripts/sc_34AN_GO_hir.R",
       local = knitr::knit_global())

# Verify that all GO terms have numeric raw and FDR p-values



# Run for BP, MF, and CC
# Output indicates if a network was generated; re-run manually if automatic network fails

## BP

GO.BP.net.list <- lapply(GO.comb[[1]], function(x)
                         GO.hierarchy.fun(x[[1]],
                                          GOBPPARENTS,
                                          "BP",
                                          "GO:0008150")
                         )

## MF

GO.MF.net.list <- lapply(GO.comb[[2]], function(x)
                         GO.hierarchy.fun(x[[1]],
                                          GOMFPARENTS,
                                          "MF",
                                          "GO:0003674")
                         )

## CC

GO.CC.net.list <- lapply(GO.comb[[3]], function(x)
                         GO.hierarchy.fun(x[[1]],
                                          GOCCPARENTS,
                                          "CC",
                                          "GO:0005575")
                         )

# Return missing networks

GO.net.miss.fun <- function(l1) {
  
  which(l1 == "Unable to create network: use alternate function")
  
}

GO.BP.mis <- GO.net.miss.fun(GO.BP.net.list)
GO.MF.mis <- GO.net.miss.fun(GO.MF.net.list)
GO.CC.mis <- GO.net.miss.fun(GO.CC.net.list)

## Save each for quick plot creation

saveRDS(GO.BP.net.list,
        "3_Analysis/4_Plots/6_GO/GO_BP_net.rds")

saveRDS(GO.MF.net.list,
        "3_Analysis/4_Plots/6_GO/GO_MF_net.rds")

saveRDS(GO.CC.net.list,
        "3_Analysis/4_Plots/6_GO/GO_CC_net.rds")


#### Section 3: Create Network Plot for Visualizing GO Results ####

## Read RDS if available

# readRDS("pathtofile.rds")

# Sunburst plot function

source("1_Scripts/sc_34AN_GO_plot_sun.R",
       local = knitr::knit_global())

# Dendrogram plot function

source("1_Scripts/sc_34AN_GO_plot_den.R",
       local = knitr::knit_global())

# Create for each network and save with and without legend

## BP

lapply(GO.BP.net.list,
       function(x) {
         
         GO.plot.sun(x[[1]],
            x[[2]],
            F,
            "noleg",
            "3_Analysis/4_Plots/6_GO/",
            "BP")
         
         GO.plot.sun(x[[1]],
            x[[2]],
            T,
            "leg",
            "3_Analysis/4_Plots/6_GO/",
            "BP")
         
       })


lapply(GO.BP.net.list,
       function(x) {
         
         GO.plot.den(x[[1]],
            x[[2]],
            "3_Analysis/4_Plots/6_GO/",
            "BP")
         
       })


## MF

lapply(GO.MF.net.list,
       function(x) {
         
         GO.plot.sun(x[[1]],
            x[[2]],
            F,
            "noleg",
            "MF")
         
         GO.plot.sun(x[[1]],
            x[[2]],
            T,
            "leg",
            "MF")
         
       })


lapply(GO.MF.net.list,
       function(x) {
         
         GO.plot.den(x[[1]],
            x[[2]],
            "3_Analysis/4_Plots/6_GO/",
            "MF")
         
       })


## CC

lapply(GO.CC.net.list,
       function(x) {
         
         GO.plot.sun(x[[1]],
            x[[2]],
            F,
            "noleg",
            "CC")
         
         GO.plot.sun(x[[1]],
            x[[2]],
            T,
            "leg",
            "CC")
         
       })


lapply(GO.CC.net.list,
       function(x) {
         
         GO.plot.den(x[[1]],
            x[[2]],
            "3_Analysis/4_Plots/6_GO/",
            "CC")
         
       })





```





# **3.5.1. General Cell Chat**

```{r, echo=T, fig.align= "center", results=T, message=T, warning=T, eval=T}

#### Section 1: Create CellChat ####

# Create Cell Chat Object from annotated Seurat object (subset by variable)

list.cc <- list(SAE = subset(data.merged.anno,
                     Airway == "SAE"),
                LAE = subset(data.merged.anno,
                     Airway == "LAE"))

## Grouping variable and save location

g.var <- "reCellGroup"

cc.save <- "3_Analysis/4_Plots/7_CellChat/7_cc_LSAE_preprocessing.rds"

cc.save2 <- "3_Analysis/4_Plots/7_CellChat/7_cc_LSAE_processed.rds"

cc.path <- "3_Analysis/4_Plots/7_CellChat/"


# Run CellChat (Takes ~15-20 mins. to complete; saves results as RDS in specified location and returns object in global envrionment)

source("1_Scripts/sc_35AN_CC_create.R",
       local = knitr::knit_global())




#### Section 2: Visualize CellChat ####

# Compile CellChat list and merge

d.chat <- mergeCellChat(list.cc,
                        add.names = names(list.cc))

d.chat.df <- subsetCommunication(d.chat)

d.chat.in <- bind_rows(d.chat.df,
                       .id = "Group")

saveRDS(d.chat.in,
        "3_Analysis/4_Plots/7_CellChat/7_cc_LSAE_plot_input.rds")


# Define groups for comparision

d.chat.g1 <- "SAE"

d.chat.g2 <- "LAE"

d.chat.groups <- c("SAE Basal","LAE Basal","SAE Ciliated","LAE Ciliated",
                                               "SAE Secretory","LAE Secretory","SAE Suprabasal","LAE Suprabasal",
                                               "SAE Cycling","LAE Cycling","LAE Rare")
d.chat.group.var <- "Airway"


# Chord Diagrams

source("1_Scripts/sc_35AN_CC_visual.R",
       local = knitr::knit_global())





## All

### Total Interactions

d.chat.in.tot <- d.chat.in %>%
  dplyr::count(Group,source,target)

d.chat.in.tot <- list(d.chat.g1 = dplyr::filter(d.chat.in.tot,Group == d.chat.g1),
                      d.chat.g2 = dplyr::filter(d.chat.in.tot,Group == d.chat.g2))

lapply(d.chat.in.tot,
       function(x) CC.Chord.fun1(x[-1],
                                 paste("7_cc_LSAE_",
                                       unique(x[1]),"_total",
                                       sep = "")
                                 )
       )


### Compare Groups

d.chat.in.com <- d.chat.in.tot[[1]] %>%
  dplyr::mutate(rat.sig = d.chat.in.tot[[1]][["n"]]/
                  d.chat.in.tot[[2]][["n"]])

d.chat.in.com <- dplyr::select(d.chat.in.com,
                               c("source","target","rat.sig"))

CC.Chord.fun2(d.chat.in.com,
              paste("7_cc_LSAE_",
                    d.chat.g1,"v",d.chat.g2,"_compare",
                    sep = ""))





## Cell-Type Specific

list.type <- unique(as.character(d.chat.in.com[[2]]))

lapply(list.type,
       function(x) {
         
         d.chat.in.typ <- d.chat.in.com %>%
          dplyr::filter(source == x)

         CC.Chord.fun2(d.chat.in.typ,
                       paste("Type/7_cc_LSAE_",
                             d.chat.g1,"v",d.chat.g2,"_",x,
                             sep = ""))
         
       })





## Pathway Specific

d.chat.in.pat <- d.chat.in %>%
  dplyr::count(Group,source,target,pathway_name)

d.chat.in.pat <- list(d.chat.g1 = dplyr::filter(d.chat.in.pat,Group == d.chat.g1),
                      d.chat.g2 = dplyr::filter(d.chat.in.pat,Group == d.chat.g2))

d.chat.in.pat <- d.chat.in.pat[[1]] %>%
  dplyr::mutate(rat.sig = d.chat.in.pat[[1]][["n"]]/
                  d.chat.in.pat[[2]][["n"]])

d.chat.in.pat[["log2.rat.sig"]] <- round(log2(d.chat.in.pat$rat.sig),
                                        digits = 2)


### display overall result as heatmap then select individual pathways

path.heat.in <- d.chat.in.pat

path.heat.in <- path.heat.in[order(path.heat.in$pathway_name),]

CC.heat.fun(path.heat.in,
            "3_Analysis/4_Plots/7_CellChat/Pathway/")





## Individual Pathways: Requires existing heatmap from previous step

### EGF

CC.path.sel.fun("EGF")

### LAMININ

CC.path.sel.fun("LAMININ")




# Communication Probability of Individual L-R Pairs (Within Specific Pathways)

### EGF

CC.dot.fun("EGF",8,6)

### LAMININ

CC.dot.fun("LAMININ",8,10)





```






